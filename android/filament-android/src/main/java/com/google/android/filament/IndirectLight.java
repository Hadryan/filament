/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.filament;

import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.Size;

import com.google.android.filament.proguard.UsedByReflection;

/**
 * <code>IndirectLight</code> is used to simulate environment lighting, a form of global illumination.
 * <p>
 * Environment lighting has a two components:
 * <ol>
 *  <li>irradiance</li>
 *  <li>reflections (specular component)</li>
 * </ol>
 *
 * Environments are usually captured as high-resolution HDR equirectangular images and processed
 * by the <b>cmgen</b> tool to generate the data needed by {@link IndirectLight}.
 *
 * <p>
 * Currently {@link IndirectLight} is intended to be used for "distant probes", that is, to represent
 * global illumination from a distant (i.e. at infinity) environment, such as the sky or distant
 * mountains. Only a single {@link IndirectLight} can be used in a {@link Scene}.
 * This limitation will be lifted in the future.
 * </p>
 *
 *
 * <h1><u>Creation and destruction</u></h1>
 *
 * An  {@link IndirectLight} object is created using the {@link IndirectLight.Builder} and
 * destroyed by calling {@link Engine#destroyIndirectLight}.
 *
 * <pre>
 *  Engine engine = Engine.create();
 *
 *  IndirectLight environment = new IndirectLight.Builder()
 *              .reflections(cubemap)
 *              .irradiance(numBands, sphericalHarmonicsCoefficients)
 *              .build(engine);
 *
 *  engine.destroyIndirectLight(environment);
 * </pre>
 *
 *
 * <h1><u>Irradiance</u></h1>
 *
 * The irradiance represents the light that comes from the environment and shines an
 * object's surface. It is represented as
 * <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">Spherical Harmonics</a> (SH) of 1, 2 or
 * 3 bands, respectively 1, 4 or 9 coefficients.
 *
 * <p>
 * Use the <b>cmgen</b> tool to generate the Spherical Harmonics for a given environment.
 * </p>
 *
 *
 * <h1><u>Reflections</u></h1>
 *
 * The reflections on object surfaces (specular component) is calculated from a specially
 * filtered cubemap pyramid generated by the <b>cmgen</b> tool.
 *
 * @see Scene
 * @see LightManager
 * @see Texture
 * @see Skybox
 */
public class IndirectLight {
    long mNativeObject;

    @UsedByReflection("KtxLoader.java")
    IndirectLight(long indirectLight) {
        mNativeObject = indirectLight;
    }

    /**
     *
     */
    public static class Builder {
        @SuppressWarnings({"FieldCanBeLocal", "UnusedDeclaration"}) // Keep to finalize native resources
        private final BuilderFinalizer mFinalizer;
        private final long mNativeBuilder;

        /**
         *
         */
        public Builder() {
            mNativeBuilder = nCreateBuilder();
            mFinalizer = new BuilderFinalizer(mNativeBuilder);
        }

        /**
         *
         * @param cubemap
         * @return
         */
        @NonNull
        public Builder reflections(@NonNull Texture cubemap) {
            nBuilderReflections(mNativeBuilder, cubemap.getNativeObject());
            return this;
        }

        /**
         *
         * @param bands
         * @param sh
         * @return
         */
        @NonNull
        public Builder irradiance(@IntRange(from=1, to=3) int bands, @NonNull float[] sh) {
            switch (bands) {
                case 1: if (sh.length < 3)
                        throw new ArrayIndexOutOfBoundsException(
                            "1 band SH, array must be at least 1 x float3"); else break;
                case 2: if (sh.length < 4 * 3)
                        throw new ArrayIndexOutOfBoundsException(
                            "2 bands SH, array must be at least 4 x float3"); else break;
                case 3: if (sh.length < 9 * 3)
                        throw new ArrayIndexOutOfBoundsException(
                            "3 bands SH, array must be at least 9 x float3"); else break;
                default: throw new IllegalArgumentException("bands must be 1, 2 or 3");
            }
            nIrradiance(mNativeBuilder, bands, sh);
            return this;
        }

        /**
         *
         * @param bands
         * @param sh
         * @return
         */
        @NonNull
        public Builder radiance(@IntRange(from=1, to=3) int bands, @NonNull float[] sh) {
            switch (bands) {
                case 1: if (sh.length < 3)
                        throw new ArrayIndexOutOfBoundsException(
                            "1 band SH, array must be at least 1 x float3"); else break;
                case 2: if (sh.length < 4 * 3)
                        throw new ArrayIndexOutOfBoundsException(
                            "2 bands SH, array must be at least 4 x float3"); else break;
                case 3: if (sh.length < 9 * 3)
                        throw new ArrayIndexOutOfBoundsException(
                            "3 bands SH, array must be at least 9 x float3"); else break;
                default: throw new IllegalArgumentException("bands must be 1, 2 or 3");
            }
            nRadiance(mNativeBuilder, bands, sh);
            return this;
        }

        /**
         *
         * @param cubemap
         * @return
         */
        @NonNull
        public Builder irradiance(@NonNull Texture cubemap) {
            nIrradianceAsTexture(mNativeBuilder, cubemap.getNativeObject());
            return this;
        }

        /**
         *
         * @param envIntensity
         * @return
         */
        @NonNull
        public Builder intensity(float envIntensity) {
            nIntensity(mNativeBuilder, envIntensity);
            return this;
        }

        /**
         *
         * @param rotation
         * @return
         */
        @NonNull
        public Builder rotation(@NonNull @Size(min = 9) float[] rotation) {
            nRotation(mNativeBuilder,
                    rotation[0], rotation[1], rotation[2],
                    rotation[3], rotation[4], rotation[5],
                    rotation[6], rotation[7], rotation[8]);
            return this;
        }

        /**
         *
         * @param engine
         * @return
         */
        @NonNull
        public IndirectLight build(@NonNull Engine engine) {
            long nativeIndirectLight = nBuilderBuild(mNativeBuilder, engine.getNativeObject());
            if (nativeIndirectLight == 0) throw new IllegalStateException("Couldn't create IndirectLight");
            return new IndirectLight(nativeIndirectLight);
        }

        private static class BuilderFinalizer {
            private final long mNativeObject;

            BuilderFinalizer(long nativeObject) { mNativeObject = nativeObject; }

            @Override
            public void finalize() {
                try {
                    super.finalize();
                } catch (Throwable t) { // Ignore
                } finally {
                    nDestroyBuilder(mNativeObject);
                }
            }
        }
    }

    /**
     *
     * @param intensity
     */
    public void setIntensity(float intensity) {
        nSetIntensity(getNativeObject(), intensity);
    }

    /**
     *
     * @return
     */
    public float getIntensity() {
        return nGetIntensity(getNativeObject());
    }

    /**
     *
     * @param rotation
     */
    public void setRotation(@NonNull @Size(min = 9) float[] rotation) {
        Asserts.assertMat3fIn(rotation);
        nSetRotation(getNativeObject(),
                rotation[0], rotation[1], rotation[2],
                rotation[3], rotation[4], rotation[5],
                rotation[6], rotation[7], rotation[8]);
    }

    /**
     *
     * @param rotation
     * @return
     */
    @NonNull @Size(min = 9)
    public float[] getRotation(@Nullable @Size(min = 9) float[] rotation) {
        rotation = Asserts.assertMat3f(rotation);
        nGetRotation(getNativeObject(), rotation);
        return rotation;
    }

    /**
     *
     * @param direction
     * @return
     */
    @NonNull @Size(min = 3)
    public float[] getDirectionEstimate(@Nullable @Size(min = 3) float[] direction) {
        direction = Asserts.assertFloat3(direction);
        nGetDirectionEstimate(getNativeObject(), direction);
        return direction;
    }

    /**
     *
     * @param colorIntensity
     * @param x
     * @param y
     * @param z
     * @return
     */
    @NonNull @Size(min = 4)
    public float[] getColorEstimate(@Nullable @Size(min = 4) float[] colorIntensity, float x, float y, float z) {
        colorIntensity = Asserts.assertFloat4(colorIntensity);
        nGetColorEstimate(getNativeObject(), colorIntensity, x, y, z);
        return colorIntensity;
    }

    /**
     *
     * @return
     */
    public long getNativeObject() {
        if (mNativeObject == 0) {
            throw new IllegalStateException("Calling method on destroyed IndirectLight");
        }
        return mNativeObject;
    }

    void clearNativeObject() {
        mNativeObject = 0;
    }

    private static native long nCreateBuilder();
    private static native void nDestroyBuilder(long nativeBuilder);

    private static native long nBuilderBuild(long nativeBuilder, long nativeEngine);
    private static native void nBuilderReflections(long nativeBuilder, long nativeTexture);
    private static native void nIrradiance(long nativeBuilder, int bands, float[] sh);
    private static native void nRadiance(long nativeBuilder, int bands, float[] sh);
    private static native void nIrradianceAsTexture(long nativeBuilder, long nativeTexture);
    private static native void nIntensity(long nativeBuilder, float envIntensity);
    private static native void nRotation(long nativeBuilder, float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float v8) ;

    private static native void nSetIntensity(long nativeIndirectLight, float intensity);
    private static native float nGetIntensity(long nativeIndirectLight);
    private static native void nSetRotation(long nativeIndirectLight, float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float v8);
    private static native void nGetRotation(long nativeIndirectLight, float[] outRotation);
    private static native void nGetDirectionEstimate(long nativeIndirectLight, float[] outDirection);
    private static native void nGetColorEstimate(long nativeIndirectLight, float[] outColor, float x, float y, float z);
}
